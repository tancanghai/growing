接口
type 接口名  interface{
     method1(参数)返回值列表
     method2(参数)返回值列表
}
实现接口所有方法
func(自定义类型)method1(参数列表)返回值列表{
//实现方法
}
func(自定义类型)method2(参数列表)返回值列表{
//实现方法
}

1.在go中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口。
2.一个自定义类型只有实现了某个接口，才能将该类型的示例（变量）赋给该类型
    var stu Stu
    var a  interface=stu//赋
    a.Say()
3.只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型
4.接口中不能有任何变量
5.一个自定义类型可以实现多个接口
6.一个a接口可以继承多个b,c接口，如果要实现这个接口需要把a,b,c接口的方法都实现
7.interface类型默认是一个指针（引用类型），如果没有对interface初始化就使用，那么会输出nil
8.空接口interface{}没有任何方法，所以所有类型都可以赋给空接口
type T interface{
}
    var t  T=stu// 把stu类型赋给T接口


例子：
package main

import (
	"fmt"
	"math/rand"
	"sort"
)

type Hero struct {
	name string
	old  int
}

type Heroslice []Hero//结构体切片

func (h Heroslice) Len() int{
	len:=len(h)
	return len
}

func (h Heroslice) Less(i,j int) bool{
	return h[i].old < h[j].old
}

func (h Heroslice) Swap(i,j int) {
	 h[j],h[i] = h[i],h[j]//交换i和j
}

func main()  {
	var heroslice Heroslice

	for i:=0;i<3;i++{
		var hero =Hero{
		name :"name",
		old:rand.Intn(100),
	}
		heroslice=append(heroslice,hero)
	}
	fmt.Println(heroslice)
	sort.Sort(heroslice)//实现sort包里面的接口的方法的排序
	fmt.Println(heroslice)
}