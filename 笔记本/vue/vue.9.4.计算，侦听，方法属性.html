<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
		<script src="js/vue.min.js" type="text/javascript"></script>

	</head>

	<body>
		<script type="text/javascript">
			//计算属性。computer
			//计算属性是基于它们的  响应式依赖   进行  缓存 的   （就是取调用一下才能执行一下的方式 ，自己不能执行需要依赖从上至下的关系 ，比如传参数等等）
			//只在相关响应式依赖发生改变时它们才会重新求值。比如参数改变
			//下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：
			//			computed: {
			//			now: function() {
			//				return Date.now()
			//			}
			//			}

			//方法。method
			//调用方法将总会再次执行函数。

			//侦听属性。watch
			//当你有一些数据需要随着其它数据变动而变动时， watch执行。

			//计算属性  VS  方法
			// 在组件中
			//			methods: {
			//				reversedMessage: function() {
			//					return this.message.split('').reverse().join('')
			//				}
			//			}
			//将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。
			//然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关 响应式依赖 发生改变时它们才会重新求值。
			//这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。

			//计算属性  vs 侦听属性
			//观察和响应 Vue 实例上的数据变动：侦听属性。
			//当你有一些数据需要随着其它数据变动而变动时，当不需要时时侦听的时候，通常更好的做法是使用计算属性而不是命令式的 watch 回调。

			//计算属性默认只有 getter， 不过在需要时你也可以提供一个 setter：
			//			computed: {
			//				fullName: {
			//					// getter
			//					get: function() {
			//						return this.firstName + ' ' + this.lastName
			//					},
			//					// setter
			//					set: function(newValue) {
			//						var names = newValue.split(' ')
			//						this.firstName = names[0]
			//						this.lastName = names[names.length - 1]
			//					}
			//				}
			//			}
		</script>
	</body>

</html>